{-# LANGUAGE DataKinds #-}
{-# LANGUAGE OverloadedStrings #-}
module Main where

import Crypto.MAC.UMAC
import Crypto.Error
import Crypto.Number.Serialize
import System.Exit
import Data.Foldable (traverse_)
import Control.Monad
import           Data.ByteArray (ScrubbedBytes, Bytes)
import qualified Data.ByteArray as BA
import           Data.ByteString (ByteString)
import qualified Data.ByteString as S

{- -----------------------------------------------------------------
-- Excerpt from RFC 4418 https://www.ietf.org/rfc/rfc4418.txt ------
--------------------------------------------------------------------
Appendix.  Test Vectors

Following are some sample UMAC outputs over a collection of input
values, using AES with 16-byte keys.  Let

  K  = "abcdefghijklmnop"                  // A 16-byte UMAC key
  N  = "bcdefghi"                          // An 8-byte nonce

The tags generated by UMAC using key K and nonce N are:

  Message      32-bit Tag    64-bit Tag            96-bit Tag
  -------      ----------    ----------            ----------
  <empty>       113145FB  6E155FAD26900BE1  32FEDB100C79AD58F07FF764
  'a' * 3       3B91D102  44B5CB542F220104  185E4FE905CBA7BD85E4C2DC
  'a' * 2^10    599B350B  26BF2F5D60118BD9  7A54ABE04AF82D60FB298C3C
  'a' * 2^15    58DCF532  27F8EF643B0D118D  7B136BD911E4B734286EF2BE
  'a' * 2^20    DB6364D1  A4477E87E9F55853  F8ACFA3AC31CFEEA047F7B11
  'a' * 2^25    5109A660  2E2DBC36860A0A5F  72C6388BACE3ACE6FBF062D9
  'abc' * 1     ABF3A3A0  D4D7B9F6BD4FBFCF  883C3D4B97A61976FFCF2323
  'abc' * 500   ABEB3C8B  D4CF26DDEFD5C01A  8824A260C53C66A36C9260A6
------------------------------------------------------------------- -}

testKey :: ByteString
testKey = "abcdefghijklmnop"

testNonce :: ByteString
testNonce = "bcdefghi"

type TestCase = ([ByteString], Bytes)

testCases :: [TestCase]
testCases =
  [ ([]                  , i2ospOf_ 8 0x6E155FAD26900BE1)
  , (["",""]             , i2ospOf_ 8 0x6E155FAD26900BE1)
  , (replicate (3   ) "a", i2ospOf_ 8 0x44B5CB542F220104)
  , (replicate (2^10) "a", i2ospOf_ 8 0x26BF2F5D60118BD9)
  , (replicate (2^15) "a", i2ospOf_ 8 0x27F8EF643B0D118D)
  , (replicate (2^20) "a", i2ospOf_ 8 0xA4477E87E9F55853)
  , (replicate (2^25) "a", i2ospOf_ 8 0x2E2DBC36860A0A5F)
  , (["abc"]             , i2ospOf_ 8 0xD4D7B9F6BD4FBFCF)
  , (replicate 500 "abc" , i2ospOf_ 8 0xD4CF26DDEFD5C01A)
  ]

main :: IO ()
main =
  do let cases = testCases ++ map mergeTest testCases
     unless (all testCompute64 cases) exitFailure
     traverse_ testStateful cases

testStateful :: TestCase -> IO ()
testStateful (chunks, expectedTag) =
  do CryptoPassed u <- new testKey :: IO (CryptoFailable (UMAC 'U64))
     traverse_ (update u) chunks
     CryptoPassed computedTag <- final u testNonce
     unless (expectedTag == computedTag) exitFailure

testCompute64 :: TestCase -> Bool
testCompute64 (chunks,tag) = compute64 chunks testKey testNonce == CryptoPassed tag

mergeTest :: TestCase -> TestCase
mergeTest (chunks, tag) = ([S.concat chunks], tag)
